**经典快速排序算法**：

	package zuoShen.class01.test;

	public class quickSort {
    public static void main(String[] args) {
        int[] arr = new int[]{11,20,11, 5, 9,11, 29, 11, 67};
        quickSort(arr, 0, arr.length - 1);
        for (int it : arr) {
            System.out.print(it + " ");
        }
    }

    public static void quickSort(int[] arr, int left, int right) {
        if (left < right) {//若left==right则到达递归基
            int p = partition(arr, left, right);//partition的过程是将局部根据key值大于key的放在左边，小于key值的放右边
            quickSort(arr, left, p - 1);//递归进行partition的过程
            quickSort(arr, p + 1, right);
        }
    }
    public static int partition(int[] arr, int left, int right) {
        int key = arr[left];//选取最左边的数作为key
        while (left < right) {
            while (arr[right] > key && right > left)//右边大于key则指针减一
                right--;
            swapArr(arr, left, right);//将小于key的数和left位置交换
            while (arr[left] <= key && right > left)//左边数小于key则指针加一
                left++;
            swapArr(arr, left, right);//将大于key的数和right位置交换
        }
        return left;//最后right==left,返回哪一个都可以
    }
	public static void swapArr(int[] arr, int l1, int l2) {
        int tmp = arr[l1];
        arr[l1] = arr[l2];
        arr[l2] = tmp;
    }
	}
以上为例：

第一轮：11 11 11 5 9 11 29 20 67 left==right=5

第二轮：9 11 5 11 11 . 11 29 20 67 left=3

第三轮:5 9 11.11 11 . 11 29 20 67 left=2 返回left=5 进行6-8过程

第四轮:5 9 11.11 11 . 11 20 29 67

经典快速排序：平均时间复杂度O(nlogn)，常数项较低 空间复杂度O(logn)(用来记录断点) 不稳定

经典快排的时间复杂度和数据状况有关系，如果数组是逆序的，那么快排的复杂度将变为O(n^2)


**改进的随机快速排序**

public static void quickSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		quickSort(arr, 0, arr.length - 1);
	}

	public static void quickSort(int[] arr, int l, int r) {
		if (l < r) {
			swap(arr, l + (int) (Math.random() * (r - l + 1)), r);//以arr[r]作为key,将数组中随机一个数与r进行交换，可以绕开原始数据状况
			int[] p = partition(arr, l, r);
			quickSort(arr, l, p[0] - 1);
			quickSort(arr, p[1] + 1, r);
		}
	}

	public static int[] partition(int[] arr, int l, int r) {
		int less = l - 1;
		int more = r;
		while (l < more) {
			if (arr[l] < arr[r]) {  //大于key，则将小于区域加一，交换完成后将current指针及l加1
				swap(arr, ++less, l++);
			} else if (arr[l] > arr[r]) {//小于key,则将大于区域的下一个数与current指针进行交换
				swap(arr, --more, l);
			} else {//等于key，则只需将current指针指向下一个位置
				l++;
			}
		}
		swap(arr, more, r);//将key与大于key左边界的数进行交换
		return new int[] { less + 1, more };//返回一个数组，记录的是与key相等的数的左边界和右边界
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
上述随机快排改进了二点：

（1）：key值选取的随机性，屏蔽原始数据的影响

（2）：记录与key值相等的区域，在下一次进行partition过程时不需要对相等的数进行比较

改进后的随机快排时间复杂度比经典快排一样，但是常数项更低